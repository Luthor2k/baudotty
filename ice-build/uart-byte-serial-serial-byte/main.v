// Code generated by Icestudio 0.10-rc1

`default_nettype none

//---- Top entity
module main #(
 parameter v57d500 = 23,
 parameter v22841d = 19,
 parameter v11011d = 1,
 parameter vd1345f = 16
) (
 input v6799f2,
 input vab3414,
 input vclk,
 output v9a8d22,
 output [7:0] vfe8966,
 output ve27779,
 output vfd848d
);
 localparam p2 = v57d500;
 localparam p3 = v11011d;
 localparam p4 = v11011d;
 localparam p5 = v22841d;
 localparam p16 = vd1345f;
 wire [0:3] w0;
 wire w1;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire [0:7] w13;
 wire w14;
 wire w15;
 wire [0:7] w17;
 wire [0:7] w18;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 assign w6 = vab3414;
 assign v9a8d22 = w7;
 assign ve27779 = w8;
 assign vfe8966 = w13;
 assign vfd848d = w14;
 assign w19 = v6799f2;
 assign w20 = vclk;
 assign w21 = vclk;
 assign w22 = vclk;
 assign w23 = vclk;
 assign w24 = vclk;
 assign w9 = w7;
 assign w10 = w7;
 assign w10 = w9;
 assign w11 = w7;
 assign w11 = w9;
 assign w11 = w10;
 assign w12 = w8;
 assign w21 = w20;
 assign w22 = w20;
 assign w22 = w21;
 assign w23 = w20;
 assign w23 = w21;
 assign w23 = w22;
 assign w24 = w20;
 assign w24 = w21;
 assign w24 = w22;
 assign w24 = w23;
 main_v9e83d4 v9e83d4 (
  .A(w0),
  .D(w18),
  .clk(w20)
 );
 main_vece981 vece981 (
  .value(w0),
  .clk(w1)
 );
 v435b29 #(
  .v100e1b(p2)
 ) v64a03b (
  .v2efea4(w1),
  .v0daa9e(w21)
 );
 main_v4a3d40 #(
  .CLKS_PER_BIT(p3)
 ) v4a3d40 (
  .i_Clock(w11),
  .i_Rx_Serial(w12),
  .o_Rx_Byte(w17)
 );
 main_vc9d136 #(
  .CLKS_PER_BIT(p4)
 ) vc9d136 (
  .o_Tx_Serial(w8),
  .i_Clock(w10),
  .i_Tx_Byte(w18),
  .i_Tx_DV(w19)
 );
 v435b29 #(
  .v100e1b(p5)
 ) vb770fa (
  .v2efea4(w7),
  .v0daa9e(w22)
 );
 main_vf7290a vf7290a (
  .reset(w6),
  .clk(w9)
 );
 main_v3c4eae v3c4eae (
 
 );
 main_v060951 v060951 (
  .D(w13),
  .digit(w14),
  .mclk(w15),
  .A(w17),
  .clk(w23)
 );
 v435b29 #(
  .v100e1b(p16)
 ) v47f59d (
  .v2efea4(w15),
  .v0daa9e(w24)
 );
endmodule

//---- Top entity
module v435b29 #(
 parameter v100e1b = 22
) (
 input v0daa9e,
 output v2efea4
);
 localparam p2 = v100e1b;
 wire w0;
 wire w1;
 assign v2efea4 = w0;
 assign w1 = v0daa9e;
 v435b29_vac7386 #(
  .N(p2)
 ) vac7386 (
  .clk_out(w0),
  .clk_in(w1)
 );
endmodule

//---------------------------------------------------
//-- PrescalerN
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Parametric N-bits prescaler
//---------------------------------------------------

module v435b29_vac7386 #(
 parameter N = 0
) (
 input clk_in,
 output clk_out
);
 //-- Number of bits of the prescaler
 //parameter N = 22;
 
 //-- divisor register
 reg [N-1:0] divcounter;
 
 //-- N bit counter
 always @(posedge clk_in)
   divcounter <= divcounter + 1;
 
 //-- Use the most significant bit as output
 assign clk_out = divcounter[N-1];
endmodule

module main_v9e83d4 (
 input clk,
 input [3:0] A,
 output [7:0] D
);
 //-- ROM memory
 reg [7:0] rom [0:15];
 
 //-- Address bus (4 bits)
 wire [3:0] A;
 
 //-- Data bus (8 bits)
 reg [7:0] D;
 
 always @(negedge clk) begin
   D <= rom[A];
 end
 
 
 //-- Memory contents 
 //-- Change them!  :-)
   initial begin
     rom[0] = 8'h41; 
     rom[1] = 8'h72;
     rom[2] = 8'h74;
     rom[3] = 8'h68;
     rom[4] = 8'h75; 
     rom[5] = 8'h72;
     rom[6] = 8'h20;
     rom[7] = 8'h48;
     rom[8] = 8'h61;
     rom[9] = 8'h7A;
     rom[10] = 8'h6C;
     rom[11] = 8'h65;
     rom[12] = 8'h64;
     rom[13] = 8'h65;
     rom[14] = 8'h6E;
     rom[15] = 8'h0A;
    end
 
endmodule

module main_vece981 (
 input clk,
 output [3:0] value
);
 reg value;
 
 always @(posedge clk)
   value <= value + 1;
 
endmodule

module main_v4a3d40 #(
 parameter CLKS_PER_BIT = 0
) (
 input i_Clock,
 input i_Rx_Serial,
 output o_Rx_DV,
 output [7:0] o_Rx_Byte
);
 //////////////////////////////////////////////////////////////////////
 // File Downloaded from http://www.nandland.com
 //////////////////////////////////////////////////////////////////////
 // This file contains the UART Receiver.  This receiver is able to
 // receive 8 bits of serial data, one start bit, one stop bit,
 // and no parity bit.  When receive is complete o_rx_dv will be
 // driven high for one clock cycle.
 // 
 // Set Parameter CLKS_PER_BIT as follows:
 // CLKS_PER_BIT = (Frequency of i_Clock)/(Frequency of UART)
 // Example: 10 MHz Clock, 115200 baud UART
 // (10000000)/(115200) = 87
   
 
   //parameter CLKS_PER_BIT,
   
   wire        i_Clock;
   wire        i_Rx_Serial;
   //output       o_Rx_DV;
   //output [7:0] o_Rx_Byte;
     
   parameter s_IDLE         = 3'b000;
   parameter s_RX_START_BIT = 3'b001;
   parameter s_RX_DATA_BITS = 3'b010;
   parameter s_RX_STOP_BIT  = 3'b011;
   parameter s_CLEANUP      = 3'b100;
    
   reg           r_Rx_Data_R = 1'b1;
   reg           r_Rx_Data   = 1'b1;
    
   reg [7:0]     r_Clock_Count = 0;
   reg [2:0]     r_Bit_Index   = 0; //8 bits total
   reg [7:0]     r_Rx_Byte     = 0;
   reg           r_Rx_DV       = 0;
   reg [2:0]     r_SM_Main     = 0;
    
   // Purpose: Double-register the incoming data.
   // This allows it to be used in the UART RX Clock Domain.
   // (It removes problems caused by metastability)
   always @(posedge i_Clock)
     begin
       r_Rx_Data_R <= i_Rx_Serial;
       r_Rx_Data   <= r_Rx_Data_R;
     end
    
    
   // Purpose: Control RX state machine
   always @(posedge i_Clock)
     begin
        
       case (r_SM_Main)
         s_IDLE :
           begin
             r_Rx_DV       <= 1'b0;
             r_Clock_Count <= 0;
             r_Bit_Index   <= 0;
              
             if (r_Rx_Data == 1'b0)          // Start bit detected
               r_SM_Main <= s_RX_START_BIT;
             else
               r_SM_Main <= s_IDLE;
           end
          
         // Check middle of start bit to make sure it's still low
         s_RX_START_BIT :
           begin
             if (r_Clock_Count == (CLKS_PER_BIT-1)/2)
               begin
                 if (r_Rx_Data == 1'b0)
                   begin
                     r_Clock_Count <= 0;  // reset counter, found the middle
                     r_SM_Main     <= s_RX_DATA_BITS;
                   end
                 else
                   r_SM_Main <= s_IDLE;
               end
             else
               begin
                 r_Clock_Count <= r_Clock_Count + 1;
                 r_SM_Main     <= s_RX_START_BIT;
               end
           end // case: s_RX_START_BIT
          
          
         // Wait CLKS_PER_BIT-1 clock cycles to sample serial data
         s_RX_DATA_BITS :
           begin
             if (r_Clock_Count < CLKS_PER_BIT-1)
               begin
                 r_Clock_Count <= r_Clock_Count + 1;
                 r_SM_Main     <= s_RX_DATA_BITS;
               end
             else
               begin
                 r_Clock_Count          <= 0;
                 r_Rx_Byte[r_Bit_Index] <= r_Rx_Data;
                  
                 // Check if we have received all bits
                 if (r_Bit_Index < 7)
                   begin
                     r_Bit_Index <= r_Bit_Index + 1;
                     r_SM_Main   <= s_RX_DATA_BITS;
                   end
                 else
                   begin
                     r_Bit_Index <= 0;
                     r_SM_Main   <= s_RX_STOP_BIT;
                   end
               end
           end // case: s_RX_DATA_BITS
      
      
         // Receive Stop bit.  Stop bit = 1
         s_RX_STOP_BIT :
           begin
             // Wait CLKS_PER_BIT-1 clock cycles for Stop bit to finish
             if (r_Clock_Count < CLKS_PER_BIT-1)
               begin
                 r_Clock_Count <= r_Clock_Count + 1;
                 r_SM_Main     <= s_RX_STOP_BIT;
               end
             else
               begin
                 r_Rx_DV       <= 1'b1;
                 r_Clock_Count <= 0;
                 r_SM_Main     <= s_CLEANUP;
               end
           end // case: s_RX_STOP_BIT
      
          
         // Stay here 1 clock
         s_CLEANUP :
           begin
             r_SM_Main <= s_IDLE;
             r_Rx_DV   <= 1'b0;
           end
          
          
         default :
           r_SM_Main <= s_IDLE;
          
       endcase
     end   
    
   assign o_Rx_DV   = r_Rx_DV;
   assign o_Rx_Byte = r_Rx_Byte;
endmodule

module main_vc9d136 #(
 parameter CLKS_PER_BIT = 0
) (
 input [7:0] i_Tx_Byte,
 input i_Clock,
 input i_Tx_DV,
 output o_Tx_Active,
 output o_Tx_Serial,
 output o_Tx_Done
);
 //////////////////////////////////////////////////////////////////////
 // File Downloaded from http://www.nandland.com
 //////////////////////////////////////////////////////////////////////
 // This file contains the UART Transmitter.  This transmitter is able
 // to transmit 8 bits of serial data, one start bit, one stop bit,
 // and no parity bit.  When transmit is complete o_Tx_done will be
 // driven high for one clock cycle.
 //
 // Set Parameter CLKS_PER_BIT as follows:
 // CLKS_PER_BIT = (Frequency of i_Clock)/(Frequency of UART)
 // Example: 10 MHz Clock, 115200 baud UART
 // (10000000)/(115200) = 87
   
 //module uart_tx 
   //#(parameter CLKS_PER_BIT)
   
   wire       i_Clock;
   wire       i_Tx_DV;
   wire [7:0] i_Tx_Byte; 
   //output      o_Tx_Active,
   //output reg  o_Tx_Serial,
   //output      o_Tx_Done
   
   parameter s_IDLE         = 3'b000;
   parameter s_TX_START_BIT = 3'b001;
   parameter s_TX_DATA_BITS = 3'b010;
   parameter s_TX_STOP_BIT  = 3'b011;
   parameter s_CLEANUP      = 3'b100;
    
   reg [2:0]    r_SM_Main     = 0;
   reg [7:0]    r_Clock_Count = 0;
   reg [2:0]    r_Bit_Index   = 0;
   reg [7:0]    r_Tx_Data     = 0;
   reg          r_Tx_Done     = 0;
   reg          r_Tx_Active   = 0;
   
   reg           r_Tx_Serial = 0;
      
   always @(posedge i_Clock)
     begin
        
       case (r_SM_Main)
         s_IDLE :
           begin
             r_Tx_Serial   <= 1'b1;         // Drive Line High for Idle
             r_Tx_Done     <= 1'b0;
             r_Clock_Count <= 0;
             r_Bit_Index   <= 0;
              
             if (i_Tx_DV == 1'b1)
               begin
                 r_Tx_Active <= 1'b1;
                 r_Tx_Data   <= i_Tx_Byte;
                 r_SM_Main   <= s_TX_START_BIT;
               end
             else
               r_SM_Main <= s_IDLE;
           end // case: s_IDLE
          
          
         // Send out Start Bit. Start bit = 0
         s_TX_START_BIT :
           begin
             r_Tx_Serial <= 1'b0;
              
             // Wait CLKS_PER_BIT-1 clock cycles for start bit to finish
             if (r_Clock_Count < CLKS_PER_BIT-1)
               begin
                 r_Clock_Count <= r_Clock_Count + 1;
                 r_SM_Main     <= s_TX_START_BIT;
               end
             else
               begin
                 r_Clock_Count <= 0;
                 r_SM_Main     <= s_TX_DATA_BITS;
               end
           end // case: s_TX_START_BIT
          
          
         // Wait CLKS_PER_BIT-1 clock cycles for data bits to finish         
         s_TX_DATA_BITS :
           begin
             r_Tx_Serial <= r_Tx_Data[r_Bit_Index];
              
             if (r_Clock_Count < CLKS_PER_BIT-1)
               begin
                 r_Clock_Count <= r_Clock_Count + 1;
                 r_SM_Main     <= s_TX_DATA_BITS;
               end
             else
               begin
                 r_Clock_Count <= 0;
                  
                 // Check if we have sent out all bits
                 if (r_Bit_Index < 7)
                   begin
                     r_Bit_Index <= r_Bit_Index + 1;
                     r_SM_Main   <= s_TX_DATA_BITS;
                   end
                 else
                   begin
                     r_Bit_Index <= 0;
                     r_SM_Main   <= s_TX_STOP_BIT;
                   end
               end
           end // case: s_TX_DATA_BITS
          
          
         // Send out Stop bit.  Stop bit = 1
         s_TX_STOP_BIT :
           begin
             r_Tx_Serial <= 1'b1;
              
             // Wait CLKS_PER_BIT-1 clock cycles for Stop bit to finish
             if (r_Clock_Count < CLKS_PER_BIT-1)
               begin
                 r_Clock_Count <= r_Clock_Count + 1;
                 r_SM_Main     <= s_TX_STOP_BIT;
               end
             else
               begin
                 r_Tx_Done     <= 1'b1;
                 r_Clock_Count <= 0;
                 r_SM_Main     <= s_CLEANUP;
                 r_Tx_Active   <= 1'b0;
               end
           end // case: s_Tx_STOP_BIT
          
          
         // Stay here 1 clock
         s_CLEANUP :
           begin
             r_Tx_Done <= 1'b1;
             r_SM_Main <= s_IDLE;
           end
          
          
         default :
           r_SM_Main <= s_IDLE;
          
       endcase
     end
  
   assign o_Tx_Serial = r_Tx_Serial;
   assign o_Tx_Active = r_Tx_Active;
   assign o_Tx_Done   = r_Tx_Done;
endmodule

module main_vf7290a (
 input clk,
 input reset,
 output tx_pin0,
 output tx_pin1,
 output tx_pin2
);
 
     //input  clk;
     //input  reset;
     //output tx_pin0,
     //output tx_pin1,
     //output tx_pin2
 
 
   wire [7:0]           text0 [0:31];
   wire [7:0]           text1 [0:31];
   wire [7:0]           text2 [0:31];
 
   // a couple of random things to push out a serial port
   assign text0[0] = "T";
   assign text0[1] = "i";
   assign text0[2] = "n";
   assign text0[3] = "y";
   assign text0[4] = "T";
   assign text0[5] = "a";
   assign text0[6] = "p";
   assign text0[7] = "e";
   assign text0[8] = "o";
   assign text0[9] = "u";
   assign text0[10] = "t";
   assign text0[11] = " ";
   assign text0[12] = "N";
   assign text0[13] = "o";
   assign text0[14] = "v";
   assign text0[15] = "2";
   assign text0[16] = "0";
   assign text0[17] = "2";
   assign text0[18] = "2";
   assign text0[19] = " ";
   assign text0[20] = "T";
   assign text0[21] = "o";
   assign text0[22] = "m";
   assign text0[23] = "K";
   assign text0[24] = "e";
   assign text0[25] = "d";
   assign text0[26] = "d";
   assign text0[27] = "i";
   assign text0[28] = "e";
   assign text0[29] = " ";
   assign text0[30] = "\r";
   assign text0[31] = "\n";
   
   assign text1[0] = "O";
   assign text1[1] = "p";
   assign text1[2] = "e";
   assign text1[3] = "n";
   assign text1[4] = " ";
   assign text1[5] = "t";
   assign text1[6] = "h";
   assign text1[7] = "e";
   assign text1[8] = " ";
   assign text1[9] = "p";
   assign text1[10] = "o";
   assign text1[11] = "d";
   assign text1[12] = " ";
   assign text1[13] = "b";
   assign text1[14] = "a";
   assign text1[15] = "y";
   assign text1[16] = " ";
   assign text1[17] = "d";
   assign text1[18] = "o";
   assign text1[19] = "o";
   assign text1[20] = "r";
   assign text1[21] = "s";
   assign text1[22] = ",";
   assign text1[23] = " ";
   assign text1[24] = "H";
   assign text1[25] = "A";
   assign text1[26] = "L";
   assign text1[27] = " ";
   assign text1[28] = " ";
   assign text1[29] = " ";
   assign text1[30] = "\r";
   assign text1[31] = "\n";
 
   assign text2[0] = "T";
   assign text2[1] = "e";
   assign text2[2] = "d";
   assign text2[3] = " ";
   assign text2[4] = "P";
   assign text2[5] = "a";
   assign text2[6] = "r";
   assign text2[7] = "k";
   assign text2[8] = "e";
   assign text2[9] = "r";
   assign text2[10] = " ";
   assign text2[11] = "2";
   assign text2[12] = "3";
   assign text2[13] = "M";
   assign text2[14] = "a";
   assign text2[15] = "r";
   assign text2[16] = "1";
   assign text2[17] = "9";
   assign text2[18] = "4";
   assign text2[19] = "2";
   assign text2[20] = "-";
   assign text2[21] = "1";
   assign text2[22] = "2";
   assign text2[23] = "A";
   assign text2[24] = "p";
   assign text2[25] = "r";
   assign text2[26] = "1";
   assign text2[27] = "9";
   assign text2[28] = "9";
   assign text2[29] = "5";
   assign text2[30] = "\r";
   assign text2[31] = "\n";
 
   reg [3:0]            bit_counter;
   reg [4:0]            text_index;
   
   reg                  tx_pin0_int;
   reg                  tx_pin1_int;
   reg                  tx_pin2_int;
   assign tx_pin0 = tx_pin0_int;
   assign tx_pin1 = tx_pin1_int;
   assign tx_pin2 = tx_pin2_int;
 
   always @(posedge clk) begin
     // if reset, set counter to 0
     if (reset) begin
       bit_counter <= 0;
       tx_pin0_int  <= 1'b1;
       tx_pin1_int  <= 1'b1;
       tx_pin2_int  <= 1'b1;
       text_index <= 0;
     end else begin
       // bit counter - START, 8xDATA, STOP, IDLE = 11 bits
       if (bit_counter == 10) begin
         // reset
         bit_counter    <= 0;
         if (text_index == 31) begin
           text_index <= 0;
         end else begin
           text_index <= text_index + 1;
         end
       end else begin
         // increment counter
         bit_counter <= bit_counter + 1;
       end
       case(bit_counter)
         0       : begin
           tx_pin0_int = 1'b1; // idle
           tx_pin1_int = 1'b1; // idle
           tx_pin2_int = 1'b1; // idle
         end
         1       : begin
           tx_pin0_int = 1'b0; // start
           tx_pin1_int = 1'b0; // start
           tx_pin2_int = 1'b0; // start
         end
         10      : begin
           tx_pin0_int = 1'b1; // stop
           tx_pin1_int = 1'b1; // stop
           tx_pin2_int = 1'b1; // stop
         end
         default : begin
           tx_pin0_int = text0[text_index][bit_counter-2];
           tx_pin1_int = text1[text_index][bit_counter-2];
           tx_pin2_int = text2[text_index][bit_counter-2];
         end
       endcase
     end
   end
endmodule

module main_v3c4eae (
 output [7:0] data
);
 //-- Displaying a 8-bit data
 //-- in the LEDs
 assign data = 8'h50; //'A'
endmodule

module main_v060951 (
 input clk,
 input [7:0] A,
 input mclk,
 output [7:0] D,
 output digit
);
 //-- ROM memory
 reg [7:0] rom [0:15];
 
 //-- Address bus (4 bits)
 wire [7:0] A;
 
 //-- Data bus (8 bits)
 reg [7:0] D;
 
 //-- Digit select (1 bit)
 reg digit;
 
 //-- multiplex clock
 wire mclk;
 
 always @(posedge mclk) begin
   digit <= ~digit;
   if(digit) D <= rom[A[3:0]];
   else D <= rom[A[7:4]];
 end
 
 
 
 
 //-- Memory contents 
 //-- Change them!  :-)
   initial begin
     rom[0] = 8'h3F; //0
     rom[1] = 8'h06; //1
     rom[2] = 8'h5B; //2
     rom[3] = 8'h4f; //3
     rom[4] = 8'h66; //4
     rom[5] = 8'h6D; //5
     rom[6] = 8'h7D; //6
     rom[7] = 8'h07; //7
     rom[8] = 8'h7F; //8
     rom[9] = 8'h6F; //9
     rom[10] = 8'h77; //A
     rom[11] = 8'h7C; //B
     rom[12] = 8'h39; //C
     rom[13] = 8'h5E; //D
     rom[14] = 8'h79; //E
     rom[15] = 8'h71; //F
    end
 
endmodule
